# Holiday Park Monitor V2 - Development Plan

## Overview
This document outlines the modernization and security improvements for Holiday Park Monitor, validated against 2025 best practices for Next.js, GCP, Firebase, and Vercel.

## Current Architecture Assessment

### Strengths
- âœ… Modern monorepo structure with TypeScript
- âœ… Proper separation of concerns (API, Web, CLI)
- âœ… App Router implementation in Next.js 14
- âœ… Firebase Authentication with whitelist control
- âœ… Docker multi-stage builds for Cloud Run
- âœ… Vercel deployment for optimal Next.js performance

### Critical Issues Identified
- ðŸ”´ Service account key file in repository
- ðŸ”´ Cloud Run endpoint publicly accessible
- ðŸ”´ Hard-coded user whitelist
- ðŸ”´ Email-based user identification
- ðŸ”´ Missing API abuse protection
- ðŸ”´ No rate limiting on authentication

## Implementation Phases

### Phase 1: Critical Security Fixes (Week 1)

#### 1.1 Replace Service Account Key with Workload Identity
**Priority: CRITICAL**

**Current Issue:**
- Service account key file exists locally (`service-account-key.json`)
- Credentials passed via environment variables
- Risk of key exposure in logs or commits

**Implementation:**
```bash
# Configure Workload Identity for Cloud Run
gcloud iam service-accounts add-iam-policy-binding \
  holiday-park-api@ai-lab-1-451411.iam.gserviceaccount.com \
  --role roles/iam.workloadIdentityUser \
  --member "serviceAccount:ai-lab-1-451411.svc.id.goog[default/holiday-park-api]"
```

**Code Changes:**
- Update `apps/api/src/config/firebase-admin.ts` to use default credentials
- Remove all `FIREBASE_PRIVATE_KEY`, `FIREBASE_CLIENT_EMAIL` environment variables
- Delete `service-account-key.json` file
- Update Cloud Build to use Workload Identity

#### 1.2 Implement Firebase App Check
**Priority: CRITICAL**

**Purpose:** Prevent unauthorized API access and bot attacks

**Implementation Steps:**

1. **Web App Configuration:**
```typescript
// apps/web/lib/firebase.ts
import { initializeAppCheck, ReCaptchaV3Provider } from 'firebase/app-check';

const appCheck = initializeAppCheck(app, {
  provider: new ReCaptchaV3Provider('YOUR_RECAPTCHA_SITE_KEY'),
  isTokenAutoRefreshEnabled: true
});
```

2. **API Validation:**
```typescript
// apps/api/src/middleware/appCheck.ts
import { admin } from '../config/firebase-admin';

export async function validateAppCheck(req: Request, res: Response, next: NextFunction) {
  const appCheckToken = req.headers['x-firebase-appcheck'];
  
  if (!appCheckToken) {
    return res.status(401).json({ error: 'Missing App Check token' });
  }
  
  try {
    await admin.appCheck().verifyToken(appCheckToken);
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid App Check token' });
  }
}
```

3. **CLI Support:**
```typescript
// apps/cli/src/services/appCheck.ts
import { initializeAppCheck, CustomProvider } from 'firebase/app-check';

// Implement debug token provider for CLI
const provider = new CustomProvider({
  getToken: async () => {
    return { token: process.env.APP_CHECK_DEBUG_TOKEN };
  }
});
```

#### 1.3 Secure Cloud Run Deployment
**Priority: CRITICAL**

**Current Issue:** Using `--allow-unauthenticated` flag

**Solution:**
1. Remove public access flag from deployment
2. Implement IAM-based authentication
3. Add Cloud Armor for DDoS protection

**Updated Cloud Build Configuration:**
```yaml
# cloudbuild.yaml changes
- name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
  args:
    - 'run'
    - 'deploy'
    - 'holiday-park-api'
    # Remove: --allow-unauthenticated
    - '--no-allow-unauthenticated'
    - '--ingress'
    - 'internal-and-cloud-load-balancing'
```

**Cloud Armor Setup:**
```bash
# Create security policy
gcloud compute security-policies create holiday-park-security \
  --description "Security policy for Holiday Park API"

# Add rate limiting rule
gcloud compute security-policies rules create 1000 \
  --security-policy holiday-park-security \
  --expression "origin.region_code == 'US'" \
  --action "rate-based-ban" \
  --rate-limit-threshold-count 100 \
  --rate-limit-threshold-interval-sec 60
```

#### 1.4 Dynamic User Authorization System
**Priority: HIGH**

**Replace hard-coded whitelist with Firestore-based configuration:**

1. **Create Firestore Collection:**
```typescript
// Structure: /authorized_users/{email}
interface AuthorizedUser {
  email: string;
  role: 'user' | 'admin';
  addedAt: Timestamp;
  addedBy: string;
  active: boolean;
}
```

2. **Update Auth Middleware:**
```typescript
// apps/api/src/middleware/auth.ts
async function isUserAuthorized(email: string): Promise<boolean> {
  const userDoc = await admin.firestore()
    .collection('authorized_users')
    .doc(email.toLowerCase())
    .get();
  
  return userDoc.exists && userDoc.data()?.active === true;
}
```

3. **Admin Management Interface:**
```typescript
// apps/web/app/admin/users/page.tsx
export default function UserManagement() {
  // UI for adding/removing authorized users
  // Only accessible to admin role users
}
```

### Phase 2: Architecture Modernization (Week 2)

#### 2.1 Next.js 15 Features Implementation
**Priority: MEDIUM**

**Partial Prerendering (PPR):**
```typescript
// apps/web/app/searches/[id]/page.tsx
export const experimental_ppr = true;

export default async function SearchPage({ params }) {
  return (
    <>
      <StaticHeader />
      <Suspense fallback={<SearchSkeleton />}>
        <DynamicSearchResults searchId={params.id} />
      </Suspense>
    </>
  );
}
```

**Server Actions Implementation:**
```typescript
// apps/web/app/actions/searches.ts
'use server';

import { revalidatePath } from 'next/cache';
import { z } from 'zod';

const createSearchSchema = z.object({
  name: z.string().min(1),
  resorts: z.array(z.number()),
  dateRanges: z.array(z.object({
    from: z.string(),
    to: z.string()
  }))
});

export async function createSearch(formData: FormData) {
  const validated = createSearchSchema.parse({
    name: formData.get('name'),
    // ... parse other fields
  });
  
  // Create search in Firestore
  await createSearchInDB(validated);
  
  revalidatePath('/searches');
}
```

**Streaming with Suspense:**
```typescript
// apps/web/app/components/StreamingResults.tsx
import { Suspense } from 'react';

export default function StreamingResults() {
  return (
    <div>
      <Suspense fallback={<ResultsSkeleton count={3} />}>
        <SearchResults />
      </Suspense>
      <Suspense fallback={<AvailabilitySkeleton />}>
        <AvailabilityChecker />
      </Suspense>
    </div>
  );
}
```

#### 2.2 Migrate to Artifact Registry
**Priority: MEDIUM**

**Steps:**
1. Create Artifact Registry repository:
```bash
gcloud artifacts repositories create holiday-park \
  --repository-format=docker \
  --location=europe-central2
```

2. Update Cloud Build:
```yaml
# cloudbuild.yaml
steps:
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'build'
      - '-t'
      - 'europe-central2-docker.pkg.dev/$PROJECT_ID/holiday-park/api:$COMMIT_SHA'
```

3. Configure authentication:
```bash
gcloud auth configure-docker europe-central2-docker.pkg.dev
```

#### 2.3 Implement Health Checks
**Priority: HIGH**

**API Health Endpoints:**
```typescript
// apps/api/src/routes/health.ts
router.get('/live', (req, res) => {
  res.status(200).json({ status: 'alive' });
});

router.get('/ready', async (req, res) => {
  try {
    // Check Firebase connection
    await admin.firestore().collection('_health').doc('check').get();
    res.status(200).json({ status: 'ready' });
  } catch (error) {
    res.status(503).json({ status: 'not ready' });
  }
});

router.get('/startup', async (req, res) => {
  // Check all dependencies are initialized
  const checks = {
    firebase: isFirebaseInitialized,
    persistence: isPersistenceReady,
    scheduler: isSchedulerReady
  };
  
  const allReady = Object.values(checks).every(check => check === true);
  res.status(allReady ? 200 : 503).json({ checks });
});
```

**Cloud Run Configuration:**
```yaml
# Update deployment to include probes
spec:
  containers:
    - image: IMAGE_URL
      livenessProbe:
        httpGet:
          path: /health/live
        periodSeconds: 30
        timeoutSeconds: 10
      readinessProbe:
        httpGet:
          path: /health/ready
        periodSeconds: 10
        timeoutSeconds: 5
      startupProbe:
        httpGet:
          path: /health/startup
        initialDelaySeconds: 0
        periodSeconds: 5
        timeoutSeconds: 10
        failureThreshold: 30
```

### Phase 3: Observability & Performance (Week 3)

#### 3.1 Structured Logging Implementation
**Priority: HIGH**

**Winston Configuration:**
```typescript
// apps/api/src/utils/logger.ts
import winston from 'winston';
import { LoggingWinston } from '@google-cloud/logging-winston';

const loggingWinston = new LoggingWinston({
  projectId: process.env.FIREBASE_PROJECT_ID,
  labels: {
    service: 'holiday-park-api',
    version: process.env.APP_VERSION || 'unknown'
  }
});

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: {
    service: 'holiday-park-api'
  },
  transports: [
    process.env.NODE_ENV === 'production'
      ? loggingWinston
      : new winston.transports.Console({
          format: winston.format.simple()
        })
  ]
});

// Correlation ID middleware
export function correlationMiddleware(req: Request, res: Response, next: NextFunction) {
  const correlationId = req.headers['x-correlation-id'] || uuidv4();
  req.correlationId = correlationId;
  res.setHeader('x-correlation-id', correlationId);
  
  // Add to logger context
  logger.defaultMeta.correlationId = correlationId;
  next();
}
```

#### 3.2 Error Tracking with Sentry
**Priority: MEDIUM**

**Setup:**
```typescript
// apps/web/app/layout.tsx
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 0.1,
  beforeSend(event, hint) {
    // Filter out sensitive data
    if (event.request?.cookies) {
      delete event.request.cookies;
    }
    return event;
  }
});

// apps/api/src/index.ts
import * as Sentry from '@sentry/node';

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  integrations: [
    new Sentry.Integrations.Http({ tracing: true }),
    new Sentry.Integrations.Express({ app })
  ],
  tracesSampleRate: 0.1
});

app.use(Sentry.Handlers.requestHandler());
app.use(Sentry.Handlers.tracingHandler());
// ... routes
app.use(Sentry.Handlers.errorHandler());
```

#### 3.3 Firestore Performance Optimization
**Priority: MEDIUM**

**Composite Indexes:**
```json
// firestore.indexes.json
{
  "indexes": [
    {
      "collectionGroup": "searches",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "enabled", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "availabilities",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "searchId", "order": "ASCENDING" },
        { "fieldPath": "resortId", "order": "ASCENDING" },
        { "fieldPath": "dateFrom", "order": "ASCENDING" }
      ]
    }
  ]
}
```

**Query Optimization:**
```typescript
// Use select() to minimize data transfer
const searches = await db.collection('searches')
  .where('userId', '==', userId)
  .where('enabled', '==', true)
  .select('id', 'name', 'lastRun', 'resorts')
  .limit(20)
  .get();

// Implement pagination with cursors
const lastDoc = await db.collection('availabilities')
  .orderBy('dateFrom')
  .limit(1)
  .get();

const nextPage = await db.collection('availabilities')
  .orderBy('dateFrom')
  .startAfter(lastDoc.docs[0])
  .limit(20)
  .get();
```

### Phase 4: API Enhancements (Week 4)

#### 4.1 API Versioning Strategy
**Priority: MEDIUM**

**Implementation:**
```typescript
// apps/api/src/routes/v1/index.ts
const v1Router = express.Router();

v1Router.use('/searches', searchesRouterV1);
v1Router.use('/results', resultsRouterV1);

// apps/api/src/routes/v2/index.ts
const v2Router = express.Router();

v2Router.use('/searches', searchesRouterV2); // With breaking changes
v2Router.use('/results', resultsRouterV2);

// apps/api/src/index.ts
app.use('/api/v1', v1Router);
app.use('/api/v2', v2Router);
app.use('/api', v1Router); // Default to v1 for backward compatibility
```

#### 4.2 Request Signing with HMAC
**Priority: LOW**

**Implementation:**
```typescript
// apps/api/src/middleware/hmac.ts
import crypto from 'crypto';

export function validateHMAC(req: Request, res: Response, next: NextFunction) {
  const signature = req.headers['x-signature'];
  const timestamp = req.headers['x-timestamp'];
  
  if (!signature || !timestamp) {
    return res.status(401).json({ error: 'Missing signature' });
  }
  
  // Check timestamp is within 5 minutes
  const now = Date.now();
  const requestTime = parseInt(timestamp as string);
  if (Math.abs(now - requestTime) > 300000) {
    return res.status(401).json({ error: 'Request expired' });
  }
  
  // Validate signature
  const payload = `${req.method}:${req.path}:${timestamp}:${JSON.stringify(req.body)}`;
  const expectedSignature = crypto
    .createHmac('sha256', process.env.API_SECRET!)
    .update(payload)
    .digest('hex');
  
  if (signature !== expectedSignature) {
    return res.status(401).json({ error: 'Invalid signature' });
  }
  
  next();
}
```

#### 4.3 Rate Limiting Enhancement
**Priority: HIGH**

**Per-User Rate Limiting:**
```typescript
// apps/api/src/middleware/rateLimiter.ts
import rateLimit from 'express-rate-limit';

export const userRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: (req) => {
    // Different limits based on user role
    if (req.user?.role === 'admin') return 1000;
    if (req.user?.role === 'premium') return 200;
    return 100; // Default for regular users
  },
  keyGenerator: (req) => req.user?.email || req.ip,
  handler: (req, res) => {
    res.status(429).json({
      error: 'Too many requests',
      retryAfter: req.rateLimit.resetTime
    });
  }
});

// Authentication attempt limiting
export const authRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts per window
  skipSuccessfulRequests: true, // Don't count successful auth
  keyGenerator: (req) => req.body.email || req.ip
});
```

## Security Checklist

### Authentication & Authorization
- [ ] Replace service account key with Workload Identity
- [ ] Implement Firebase App Check
- [ ] Move whitelist to Firestore configuration
- [ ] Add rate limiting on authentication attempts
- [ ] Implement proper user ID generation (UUID, not email)
- [ ] Add audit logging for auth events

### API Security
- [ ] Remove `--allow-unauthenticated` from Cloud Run
- [ ] Implement Cloud Armor DDoS protection
- [ ] Add request signing with HMAC
- [ ] Implement per-user rate limiting
- [ ] Add input validation with Zod schemas
- [ ] Implement API versioning

### Data Protection
- [ ] Enable Firestore audit logs
- [ ] Implement field-level encryption for sensitive data
- [ ] Add data retention policies
- [ ] Set up automated backups
- [ ] Implement data anonymization for logs

### Infrastructure Security
- [ ] Migrate to Artifact Registry
- [ ] Implement least-privilege IAM roles
- [ ] Enable Binary Authorization for containers
- [ ] Add vulnerability scanning in CI/CD
- [ ] Implement secret rotation with Secret Manager

## Migration Timeline

### Week 1: Critical Security
- Day 1-2: Workload Identity setup
- Day 3-4: Firebase App Check implementation
- Day 5: Cloud Run security hardening

### Week 2: Architecture Updates
- Day 1-2: Next.js 15 features
- Day 3: Artifact Registry migration
- Day 4-5: Health checks and probes

### Week 3: Observability
- Day 1-2: Structured logging
- Day 3: Sentry integration
- Day 4-5: Firestore optimization

### Week 4: API Improvements
- Day 1-2: API versioning
- Day 3: HMAC implementation
- Day 4-5: Enhanced rate limiting

## Rollback Strategy

Each phase includes rollback capabilities:

1. **Feature Flags:** Use environment variables to toggle new features
2. **Blue-Green Deployment:** Maintain previous version in Cloud Run
3. **Database Migrations:** Version all Firestore schema changes
4. **API Versioning:** Maintain v1 while introducing v2

## Success Metrics

### Security Metrics
- Zero service account keys in codebase
- 100% of API calls validated with App Check
- < 0.1% unauthorized access attempts successful
- 100% of sensitive operations audit logged

### Performance Metrics
- P95 API response time < 500ms
- Next.js Core Web Vitals score > 90
- Firestore read operations reduced by 40%
- Zero unhandled errors in production

### Operational Metrics
- Mean time to recovery (MTTR) < 30 minutes
- Deployment success rate > 99%
- Test coverage > 80%
- Security scan findings addressed within 48 hours

## Documentation Updates Required

1. Update CLAUDE.md with new architecture
2. Create SECURITY.md with security policies
3. Update API documentation with v2 endpoints
4. Create runbooks for incident response
5. Document secret rotation procedures

---

*Last Updated: 2025-09-01*
*Version: 2.0.0-planning*